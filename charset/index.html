<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>Mini Font Creator</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body{font-family:system-ui,sans-serif;background:#f4f4f4;margin:1rem;text-align:center;}
h1,h2{margin:.5rem 0;}
canvas{border:1px solid #ccc;background:#fff;cursor:crosshair;touch-action:none;}
#glyphMap{display:grid;grid-template-columns:repeat(auto-fill,minmax(30px,1fr));
  gap:2px;max-height:220px;overflow:auto;margin:1rem 0;border:1px solid #ccc;
  padding:5px;background:#fff;}
.glyphBtn{padding:5px;border:1px solid #888;border-radius:4px;cursor:pointer;
  font-size:18px;user-select:none;background:#eee;}
.glyphBtn.selected{background:#2c7;color:#fff;font-weight:bold;}
button{margin:.3rem;padding:.5rem 1rem;background:#2c7;border:none;
  border-radius:4px;color:#fff;font-weight:bold;cursor:pointer;}
button:hover{background:#28a;}
#preview{margin-top:1rem;font-size:48px;}
</style>
</head>
<body>
<h1>Mini Font Creator</h1>

<div id="glyphMap"></div>

<canvas id="draw" width="400" height="400"></canvas><br>
<button id="saveGlyph">Glyph speichern</button>
<button id="clear">Alles löschen</button>
<button id="download">TTF exportieren</button>
<button id="undoBtn">Undo</button>
<button id="redoBtn">Redo</button>

<h2>Live-Preview</h2>
<input id="previewText" value="ABC" style="width:300px;"><br>
<div id="preview"></div>

<script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
<script>
// -----------------------------
// Windows-1252 druckbare Zeichen 32–255 (0x7F und 0x80-0x9F ausgeschlossen)
const win1252 = [];
for(let i=32;i<=255;i++){
  if(i===127||(i>=0x80&&i<=0x9F)) continue;
  win1252.push(String.fromCharCode(i));
}

// Latin Extended-A (U+0100–U+017F)
const latinExtA = [];
for(let i=0x0100;i<=0x017F;i++) latinExtA.push(String.fromCharCode(i));

// Extra-Zeichen am Ende
const extraBack = ['ƒ','Ș','ș','Ț','ț','†','…','π'];

// Endgültige Zeichentabelle
const charset = [...win1252, ...latinExtA, ...extraBack];

// -----------------------------
const mapDiv = document.getElementById('glyphMap');
let selectedGlyph = null;
const savedPaths = {};
const glyphs = [];
let segments = [];
let currentSegment = [];
let drawing = false;
let undoStack = [];
let redoStack = [];

// Undo/Redo
function pushUndo(){ undoStack.push(segments.map(s=>[...s])); if(undoStack.length>50) undoStack.shift(); }
function undo(){ if(!undoStack.length) return; redoStack.push(segments.map(s=>[...s])); segments=undoStack.pop(); redrawPath(); }
function redo(){ if(!redoStack.length) return; undoStack.push(segments.map(s=>[...s])); segments=redoStack.pop(); redrawPath(); }

// Canvas
const cvs = document.getElementById('draw');
const ctx = cvs.getContext('2d');
function clearCanvas(){ ctx.clearRect(0,0,cvs.width,cvs.height); segments=[]; currentSegment=[]; }
function getTouchPos(t){ const r=cvs.getBoundingClientRect(); return {x:t.clientX-r.left,y:t.clientY-r.top}; }
function redrawPath(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  segments.forEach(seg=>{
    if(!seg.length) return;
    ctx.beginPath();
    ctx.moveTo(seg[0].x, seg[0].y);
    for(let i=1;i<seg.length;i++) ctx.lineTo(seg[i].x, seg[i].y);
    ctx.stroke();
  });
}

// Zeichnen
cvs.onmousedown = e => { drawing=true; pushUndo(); currentSegment=[{x:e.offsetX,y:e.offsetY}]; ctx.beginPath(); ctx.moveTo(e.offsetX,e.offsetY); };
cvs.onmousemove = e => { if(!drawing) return; currentSegment.push({x:e.offsetX,y:e.offsetY}); ctx.lineTo(e.offsetX,e.offsetY); ctx.stroke(); };
cvs.onmouseup = () => { if(drawing){ drawing=false; segments.push([...currentSegment]); currentSegment=[]; } };

cvs.addEventListener('touchstart', e => { e.preventDefault(); const t=getTouchPos(e.touches[0]); drawing=true; pushUndo(); currentSegment=[t]; ctx.beginPath(); ctx.moveTo(t.x,t.y); });
cvs.addEventListener('touchmove', e => { e.preventDefault(); if(!drawing) return; const t=getTouchPos(e.touches[0]); currentSegment.push(t); ctx.lineTo(t.x,t.y); ctx.stroke(); });
cvs.addEventListener('touchend', e => { if(drawing){ drawing=false; segments.push([...currentSegment]); currentSegment=[]; } });

// Glyph-Buttons erzeugen
charset.forEach(ch=>{
  const btn=document.createElement('div');
  btn.className='glyphBtn';
  btn.textContent=ch;
  btn.onclick=()=>{
    document.querySelectorAll('.glyphBtn').forEach(b=>b.classList.remove('selected'));
    btn.classList.add('selected');
    selectedGlyph=ch; redoStack=[]; undoStack=[]; clearCanvas();
    if(savedPaths[ch]){ segments=savedPaths[ch].map(seg=>[...seg]); redrawPath(); }
  };
  mapDiv.appendChild(btn);
});

// Glyph speichern
document.getElementById('saveGlyph').onclick=()=>{
  if(!selectedGlyph){ alert('Bitte Glyph auswählen!'); return; }
  if(!segments.length){ alert('Bitte zeichnen!'); return; }

  savedPaths[selectedGlyph]=segments.map(seg=>[...seg]);

  const path=new opentype.Path();
  segments.forEach(seg=>{
    if(seg.length<2) return;
    path.moveTo(seg[0].x,1000-seg[0].y);
    for(let i=1;i<seg.length;i++) path.lineTo(seg[i].x,1000-seg[i].y);
  });

  const code=selectedGlyph.charCodeAt(0);
  const newGlyph=new opentype.Glyph({
    name:'uni'+code.toString(16).toUpperCase(),
    unicodes:[code],
    advanceWidth:600,
    path:path
  });

  const idx=glyphs.findIndex(g=>g.unicodes[0]===code);
  if(idx>=0) glyphs[idx]=newGlyph; else glyphs.push(newGlyph);

  localStorage.setItem('miniFontSavedPaths', JSON.stringify(savedPaths));
  alert(`Glyph "${selectedGlyph}" gespeichert!`);
  updatePreview();
};

// Buttons
document.getElementById('clear').onclick=()=>{ if(selectedGlyph) savedPaths[selectedGlyph]=[]; clearCanvas(); localStorage.setItem('miniFontSavedPaths',JSON.stringify(savedPaths)); };
document.getElementById('undoBtn').onclick=undo;
document.getElementById('redoBtn').onclick=redo;

// TTF Export mit Fallback für leere ASCII-Glyphen
document.getElementById('download').onclick = () => {
  if(!glyphs.length){ alert('Keine Glyphen vorhanden!'); return; }

  // Notdef-Glyph
  const notdef = new opentype.Glyph({
      name: '.notdef',
      unicode: 0,
      advanceWidth: 600,
      path: new opentype.Path()
  });

  // Standardbuchstabe A
  const hasA = glyphs.some(g => g.unicodes.includes(65)); 
  if(!hasA){
      const pathA = new opentype.Path();
      pathA.moveTo(150,0); pathA.lineTo(450,0); pathA.lineTo(300,700); pathA.close();
      const glyphA = new opentype.Glyph({
          name:'A',
          unicode:[65],
          advanceWidth:600,
          path:pathA
      });
      glyphs.push(glyphA);
  }

  // Fallback: leere ASCII-Zeichen
  const glyphsWithFallback = glyphs.map(g=>{
      const code = g.unicodes[0];
      if(code>=32 && code<=126){
          if(!g.path.commands || !g.path.commands.length){
              const p = new opentype.Path();
              p.moveTo(200,200);
              p.lineTo(400,200);
              p.lineTo(400,400);
              p.lineTo(200,400);
              p.close();
              return new opentype.Glyph({
                  name: g.name,
                  unicodes: g.unicodes,
                  advanceWidth: 600,
                  path: p
              });
          }
      }
      return g;
  });

  const allGlyphs = [notdef, ...glyphsWithFallback];

  const font = new opentype.Font({
      familyName: 'MyMiniFont',
      styleName: 'Regular',
      unitsPerEm: 1000,
      ascender: 800,
      descender: -200,
      glyphs: allGlyphs
  });

  const arrayBuffer = font.toArrayBuffer();
  const blob = new Blob([arrayBuffer], {type:'font/ttf'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'MyMiniFont.ttf';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Live-Preview
const previewInput=document.getElementById('previewText');
const previewDiv=document.getElementById('preview');
function updatePreview(){
  if(!glyphs.length) return;
  const tempFont=new opentype.Font({
    familyName:'TempFont',
    styleName:'Regular',
    unitsPerEm:1000,
    ascender:800,
    descender:-200,
    glyphs:glyphs
  });
  const fontUrl=tempFont.toDataURL();
  let style=document.getElementById('tempFontStyle');
  if(!style){ style=document.createElement('style'); style.id='tempFontStyle'; document.head.appendChild(style); }
  style.innerHTML=`@font-face{font-family:'TempFont';src:url(${fontUrl});}`;
  previewDiv.style.fontFamily='TempFont';
  previewDiv.textContent=previewInput.value;
}
previewInput.addEventListener('input',updatePreview);

// Auto-Load
window.addEventListener('load',()=>{
  const saved=localStorage.getItem('miniFontSavedPaths');
  if(saved){ try{ const obj=JSON.parse(saved); for(const k in obj){ savedPaths[k]=obj[k]; } } catch(e){ console.warn(e); } }
  updatePreview();
});
</script>
</body>
</html>
