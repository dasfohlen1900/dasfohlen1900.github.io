<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-2048 – BMG-Colors</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#071019;
    --text:#e6eef6;
    --tile-size:90px;
    --gap:12px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:linear-gradient(180deg,#031217,#07121a);
    color:var(--text);font-family:Inter, system-ui, Arial;display:flex;align-items:center;justify-content:center;
    min-height:100vh;padding:24px;
  }
  .wrap{max-width:520px;width:100%}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
  h1{font-family:'Bungee', sans-serif;font-size:1.45rem;margin:0}
  .scores{display:flex;gap:8px;align-items:center}
  .score-box{background:rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;font-weight:700}

  .board {
    background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.12));
    padding:var(--gap);
    border-radius:16px;
    display:grid;
    grid-template-columns:repeat(4, var(--tile-size));
    grid-template-rows:repeat(4, var(--tile-size));
    gap:var(--gap);
    justify-content:center;
    box-shadow:0 12px 40px rgba(0,0,0,0.6);
    margin-bottom:14px;
    position:relative;
  }
  .cell {
    width:var(--tile-size);height:var(--tile-size);
    background:rgba(255,255,255,0.03);
    border-radius:10px;
  }

  /* tile */
  .tile {
    position:absolute;
    width:var(--tile-size);height:var(--tile-size);
    display:flex;align-items:center;justify-content:center;
    border-radius:10px;font-weight:800;font-size:1.15rem;
    transition: transform 160ms ease, left 160ms ease, top 160ms ease;
    box-shadow: 0 6px 18px rgba(0,0,0,0.5);
    user-select:none;
  }
  .tile.new { transform: scale(0.2); animation:pop .14s ease forwards; }
  .tile.merge { animation:merge .14s ease; }

  @keyframes pop { to { transform: scale(1); } }
  @keyframes merge { 0% { transform: scale(1.1); } 50% { transform: scale(0.95); } 100% { transform: scale(1); } }

  /* color mapping */
  .val-2{background:#e74c3c;color:#fff}
  .val-4{background:#e67e22;color:#fff}
  .val-8{background:#f6d55c;color:#111}
  .val-16{background:#c7f464;color:#111}
  .val-32{background:#6ec1e4;color:#111}
  .val-64{background:#0b3d91;color:#fff}
  .val-128{background:#ff69b4;color:#111}
  .val-256{background:#8e44ad;color:#fff}
  .val-512{background:#9b111e;color:#fff}
  .val-1024{background:#2ecc71;color:#111}
  .val-2048{
    background:linear-gradient(135deg,#008c45,#006f3c);
    color:#fff;border:2px solid rgba(0,0,0,0.2);
  }

  .controls {display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .btn{background:#0e6f3b;color:white;padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .hint{font-size:0.85rem;opacity:0.8}
  .overlay{position:relative}
  .msg{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);border-radius:12px;color:white;font-size:1.15rem;flex-direction:column;gap:10px}
  .small{font-size:0.9rem;opacity:0.95}
</style>
<link href="https://fonts.googleapis.com/css2?family=Bungee&display=swap" rel="stylesheet">
</head>
<body>
<div class="wrap">
  <header>
    <h1>Mini-2048</h1>
    <div class="scores">
      <div class="score-box">Score <span id="score">0</span></div>
      <div class="score-box">Best <span id="best">0</span></div>
    </div>
  </header>

  <div class="controls">
    <button class="btn" id="newGame">Neues Spiel</button>
    <button class="btn ghost" id="undo" title="Rückgängig (1 Schritt)">Undo</button>
    <div class="hint small">Steuerung: Pfeile / W A S D / Swipe</div>
  </div>

  <div class="overlay">
    <div id="board" class="board" aria-hidden="false"></div>
    <div id="message" class="msg" style="display:none">
      <div id="msgText">Du hast gewonnen!</div>
      <div>
        <button class="btn" id="continueBtn">Weiter spielen</button>
        <button class="btn ghost" id="restartBtn">Neu starten</button>
      </div>
    </div>
  </div>
</div>

<script>
const SIZE = 4;
const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const newBtn = document.getElementById('newGame');
const message = document.getElementById('message');
const msgText = document.getElementById('msgText');
const continueBtn = document.getElementById('continueBtn');
const restartBtn = document.getElementById('restartBtn');
const undoBtn = document.getElementById('undo');

let grid = [];
let tiles = [];
let score = 0;
let best = parseInt(localStorage.getItem('mini2048_best')||'0',10);
let canUndo = null;
bestEl.textContent = best;

const tileSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 90;
const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 12;
const boardRectWidth = SIZE*tileSize + (SIZE-1)*gap;

for(let i=0;i<SIZE*SIZE;i++){
  const c = document.createElement('div');
  c.className='cell';
  boardEl.appendChild(c);
}

function newGrid(){ return Array.from({length:SIZE},()=>Array(SIZE).fill(null)) }

function spawnRandom(){
  const empties=[];
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!grid[r][c]) empties.push({r,c});
  if(!empties.length) return false;
  const {r,c}=empties[Math.floor(Math.random()*empties.length)];
  const val=Math.random()<0.9?2:4;
  grid[r][c]={value:val,id:idGen(),new:true};
  render();
  return true;
}

let idCounter=1;
function idGen(){ return 't'+(idCounter++) }

function render(){
  tiles.forEach(t=>t.el.remove());
  tiles=[];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const cell=grid[r][c];
      if(cell){
        const el=document.createElement('div');
        el.className='tile val-'+cell.value+(cell.new?' new':'');
        el.dataset.id=cell.id;
        el.innerText=cell.value;
        el.style.left = c*(tileSize+gap)+'px';
        el.style.top  = r*(tileSize+gap)+'px';
        if(cell.value>=1024) el.style.fontSize='0.95rem';
        boardEl.appendChild(el);
        tiles.push({id:cell.id,el});
        delete cell.new;
      }
    }
  }
  scoreEl.textContent=score;
  bestEl.textContent=best;
}

function move(direction){
  saveUndo();
  let moved=false;
  const rangeR = direction==='down'? [...Array(SIZE).keys()].reverse() : [...Array(SIZE).keys()];
  const rangeC = direction==='right'? [...Array(SIZE).keys()].reverse() : [...Array(SIZE).keys()];
  const merged = new Set();

  if(direction==='left' || direction==='right'){
    const step = direction==='left' ? -1 : 1;
    for(let r=0;r<SIZE;r++){
      for(let c of rangeC){
        if(!grid[r][c]) continue;
        let cr=c; const val=grid[r][c].value;
        while(true){
          const nc = cr + step;
          if(nc<0||nc>=SIZE) break;
          if(!grid[r][nc]){
            grid[r][nc]=grid[r][cr]; grid[r][cr]=null; cr=nc; moved=true;
          } else if(grid[r][nc].value===val && !merged.has(grid[r][nc].id) && !merged.has(grid[r][cr].id)){
            grid[r][nc].value*=2;
            grid[r][nc].id=idGen();
            grid[r][nc].new=true;
            grid[r][cr]=null;
            score+=grid[r][nc].value;
            if(score>best){ best=score; localStorage.setItem('mini2048_best',best); }
            merged.add(grid[r][nc].id);
            moved=true;
            break;
          } else break;
        }
      }
    }
  } else {
    const step = direction==='up' ? -1 : 1;
    for(let c=0;c<SIZE;c++){
      for(let r of rangeR){
        if(!grid[r][c]) continue;
        let rr=r; const val=grid[r][c].value;
        while(true){
          const nr = rr + step;
          if(nr<0||nr>=SIZE) break;
          if(!grid[nr][c]){
            grid[nr][c]=grid[rr][c]; grid[rr][c]=null; rr=nr; moved=true;
          } else if(grid[nr][c].value===val && !merged.has(grid[nr][c].id) && !merged.has(grid[rr][c].id)){
            grid[nr][c].value*=2;
            grid[nr][c].id=idGen();
            grid[nr][c].new=true;
            grid[rr][c]=null;
            score+=grid[nr][c].value;
            if(score>best){ best=score; localStorage.setItem('mini2048_best',best); }
            merged.add(grid[nr][c].id);
            moved=true;
            break;
          } else break;
        }
      }
    }
  }

  if(moved){
    spawnRandom();
    render();
    if(checkWin()) showMessage('Glückwunsch — 2048 erreicht!');
    else if(!movesAvailable()) showMessage('Game Over – keine Züge mehr');
  } else {
    canUndo=null;
  }
}

function movesAvailable(){
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
    if(!grid[r][c]) return true;
    const v=grid[r][c].value;
    if(r+1<SIZE && grid[r+1][c] && grid[r+1][c].value===v) return true;
    if(c+1<SIZE && grid[r][c+1] && grid[r][c+1].value===v) return true;
  }
  return false;
}
function checkWin(){ for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(grid[r][c]&&grid[r][c].value===2048) return true; return false; }

function saveUndo(){
  canUndo={grid:JSON.parse(JSON.stringify(grid)),score,idCounter};
  undoBtn.disabled=false;
}
undoBtn.addEventListener('click',()=>{
  if(!canUndo) return;
  grid=JSON.parse(JSON.stringify(canUndo.grid));
  score=canUndo.score;
  idCounter=canUndo.idCounter;
  canUndo=null;
  undoBtn.disabled=true;
  render();
});

window.addEventListener('keydown',(e)=>{
  const map={
    ArrowUp:'up','w':'up','W':'up',
    ArrowDown:'down','s':'down','S':'down',
    ArrowLeft:'left','a':'left','A':'left',
    ArrowRight:'right','d':'right','D':'right'
  };
  const dir=map[e.key];
  if(dir){ e.preventDefault(); move(dir); }
});

let touchStart=null;
document.addEventListener('touchstart',e=>{
  if(e.touches.length===1) touchStart={x:e.touches[0].clientX,y:e.touches[0].clientY};
});
document.addEventListener('touchend',e=>{
  if(!touchStart) return;
  const end=e.changedTouches[0];
  const dx=end.clientX-touchStart.x;
  const dy=end.clientY-touchStart.y;
  if(Math.abs(dx)<20 && Math.abs(dy)<20) return;
  if(Math.abs(dx)>Math.abs(dy)) move(dx>0?'right':'left');
  else move(dy>0?'down':'up');
  touchStart=null;
});

function showMessage(text){
  msgText.innerText=text;
  message.style.display='flex';
}
newBtn.addEventListener('click',initGame);
continueBtn.addEventListener('click',()=> message.style.display='none');
restartBtn.addEventListener('click',()=>{ message.style.display='none'; initGame(); });

function initGame(){
  grid=newGrid();
  score=0;
  idCounter=1;
  canUndo=null;
  undoBtn.disabled=true;
  spawnRandom(); spawnRandom();
  render();
  message.style.display='none';
  boardEl.style.width=boardRectWidth+'px';
  boardEl.style.height=boardRectWidth+'px';
}

function saveState(){
  localStorage.setItem('mini2048_state',JSON.stringify({grid,score,best,idCounter}));
}
function loadState(){
  const s=localStorage.getItem('mini2048_state');
  if(!s) return false;
  try{
    const o=JSON.parse(s);
    grid=o.grid; score=o.score; best=o.best||best; idCounter=o.idCounter||idCounter;
    return true;
  }catch{ return false; }
}

window.addEventListener('beforeunload',saveState);
if(!loadState()) initGame(); else render();
</script>
</body>
</html>
