<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>Mini Font Creator – Strich-Lines</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body{font-family:system-ui,sans-serif;background:#f4f4f4;margin:1rem;text-align:center;}
h1,h2{margin:0.5rem 0;}
canvas{border:1px solid #ccc;background:#fff;cursor:crosshair;touch-action:none;}
#glyphMap{display:grid;grid-template-columns:repeat(auto-fill, minmax(30px,1fr));gap:2px;max-height:200px;overflow:auto;margin:1rem 0;border:1px solid #ccc;padding:5px;background:#fff;}
.glyphBtn{padding:5px;border:1px solid #888;border-radius:4px;cursor:pointer;font-size:18px;user-select:none;background:#eee;}
.glyphBtn.selected{background:#2c7;color:#fff;font-weight:bold;}
button{margin:.3rem;padding:.5rem 1rem;background:#2c7;border:none;border-radius:4px;color:#fff;font-weight:bold;cursor:pointer;}
button:hover{background:#28a;}
#preview{margin-top:1rem;font-size:48px;}
</style>
</head>
<body>
<h1>Mini Font Creator – Strich-Lines</h1>

<div id="glyphMap"></div>

<canvas id="draw" width="400" height="400"></canvas><br>
<button id="saveGlyph">Glyph speichern</button>
<button id="clear">Alles löschen</button>
<button id="download">TTF exportieren</button>
<button id="undoBtn">Undo</button>
<button id="redoBtn">Redo</button>

<h2>Live-Preview</h2>
<input id="previewText" value="ABC" style="width:300px;"><br>
<div id="preview"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/0.6.5/opentype.min.js"></script>
<script>
// -----------------------------
// Vollständiges Charset
const charset = [
"Null","←","↑","→","↓","↔","↕","═","║","╔","╗","╚","╝","🗕","🗖","🗗",
"🗙","π","Δ","","😀","😢","‟","T́","t́","𝄞","🡰","🡱","🡲","🡳","↰","↱",
"Sp","!","\"","#","$","%","&","'","(",")","+","-",".","/",
"0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?",
"@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O",
"P","Q","R","S","T","U","V","W","X","Y","Z","[","\\","]","^","_",
"`","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o",
"p","q","r","s","t","u","v","w","x","y","z","{","|","}","~",
"€","‚","ƒ","„","…","†","‡","ˆ","‰","Š","‹","Œ","Î","Ž","ć","ð",
"Ć","‘","’","“","”","•","–","—","˜","™","š","›","œ","î","ž","Ÿ",
"NBSP","¡","V̶","£","¤","¥","¦","§","¨","©","ª","«","¬","SHY","®","¯",
"°","±","²","³","´","µ","¶","·","¸","¹","º","»","¼","½","¾","¿",
"À","Á","Â","Ã","Ä","Ą","Ä́","Ç","È","É","Ê","Ë","Ì","Í","Ě","Ï",
"Ď","Ñ","Ò","Ó","Ô","Õ","Ö","×","Ř","Ù","Ú","Û","Ü","Ý","f̌","ß",
"à","á","â","ã","ä","ą","ä́","ç","è","é","ê","ë","ì","í","ě","ï",
"ď","ñ","ò","ó","ô","õ","ö","÷","ř","ù","ú","û","ü","ý","🐙","ÿ"
];

// -----------------------------
// PUA Mapping
const puaMap = {
  "T́": { upper: 0xE000, lower: 0xE001 },
  "F̌": { upper: null, lower: 0xE002 },
  "Ä́": { upper: 0xE003, lower: 0xE004 }
};

// -----------------------------
// Glyphen-Map & Canvas Setup
const mapDiv = document.getElementById('glyphMap');
let selectedGlyph = null;
const savedPaths = {}; // Pfade persistent
const glyphs = [];
let segments = []; // Alle Linien-Segmente der aktuellen Glyph
let currentSegment = [];
let drawing = false;

// Undo/Redo
let undoStack = [];
let redoStack = [];
function pushUndo(){ undoStack.push(segments.map(seg=>[...seg])); if(undoStack.length>50) undoStack.shift(); }
function undo(){ if(!undoStack.length) return; redoStack.push(segments.map(seg=>[...seg])); segments=undoStack.pop(); redrawPath(); }
function redo(){ if(!redoStack.length) return; undoStack.push(segments.map(seg=>[...seg])); segments=redoStack.pop(); redrawPath(); }

// -----------------------------
// Canvas
const cvs = document.getElementById('draw');
const ctx = cvs.getContext('2d');
function clearCanvas(){ ctx.clearRect(0,0,cvs.width,cvs.height); segments=[]; currentSegment=[]; }

function getTouchPos(touch){ const rect=cvs.getBoundingClientRect(); return { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; }

function redrawPath(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  segments.forEach(seg=>{
    if(!seg.length) return;
    ctx.beginPath();
    ctx.moveTo(seg[0].x, seg[0].y);
    for(let i=1;i<seg.length;i++) ctx.lineTo(seg[i].x, seg[i].y);
    ctx.stroke();
  });
}

// Maus & Touch Events
cvs.onmousedown = e => { drawing=true; pushUndo(); currentSegment=[{x:e.offsetX,y:e.offsetY}]; ctx.beginPath(); ctx.moveTo(e.offsetX,e.offsetY); };
cvs.onmousemove = e => { if(!drawing) return; currentSegment.push({x:e.offsetX,y:e.offsetY}); ctx.lineTo(e.offsetX,e.offsetY); ctx.stroke(); };
cvs.onmouseup = () => { if(drawing) {drawing=false; segments.push([...currentSegment]); currentSegment=[];} };

cvs.addEventListener('touchstart', e => { e.preventDefault(); const t=getTouchPos(e.touches[0]); drawing=true; pushUndo(); currentSegment=[t]; ctx.beginPath(); ctx.moveTo(t.x,t.y); });
cvs.addEventListener('touchmove', e => { e.preventDefault(); if(!drawing) return; const t=getTouchPos(e.touches[0]); currentSegment.push(t); ctx.lineTo(t.x,t.y); ctx.stroke(); });
cvs.addEventListener('touchend', e => { if(drawing) {drawing=false; segments.push([...currentSegment]); currentSegment=[];} });

// -----------------------------
// Glyphen-Map erstellen
mapDiv.innerHTML='';
charset.forEach(char => {
  const btn = document.createElement('div');
  btn.className='glyphBtn';
  btn.textContent=char;
  if(puaMap[char]){ btn.style.borderColor='#d33'; btn.title='PUA Glyph'; }
  btn.onclick = () => {
    document.querySelectorAll('.glyphBtn').forEach(b=>b.classList.remove('selected'));
    btn.classList.add('selected');
    selectedGlyph=char; redoStack=[]; undoStack=[]; clearCanvas();
    if(savedPaths[selectedGlyph]){ segments=savedPaths[selectedGlyph].map(seg=>[...seg]); redrawPath(); }
    else segments=[];
    btn.scrollIntoView({behavior:'smooth', block:'nearest', inline:'nearest'});
  };
  mapDiv.appendChild(btn);
});

// -----------------------------
// Speichern Glyph
document.getElementById('saveGlyph').onclick = () => {
  if(!selectedGlyph){ alert('Bitte Glyph auswählen!'); return; }
  if(!segments.length){ alert('Bitte zeichnen!'); return; }

  savedPaths[selectedGlyph] = segments.map(seg=>[...seg]);

  const opentypePath = new opentype.Path();
  segments.forEach(seg=>{
    if(seg.length<2) return;
    opentypePath.moveTo(seg[0].x, 400 - seg[0].y);
    for(let i=1;i<seg.length;i++) opentypePath.lineTo(seg[i].x, 400 - seg[i].y);
  });

  let codes;
  if(puaMap[selectedGlyph]){
    if(selectedGlyph === selectedGlyph.toUpperCase() && puaMap[selectedGlyph].upper) codes=[puaMap[selectedGlyph].upper];
    else if(puaMap[selectedGlyph].lower) codes=[puaMap[selectedGlyph].lower];
    else codes=[selectedGlyph.charCodeAt(0)];
  } else codes=[selectedGlyph.charCodeAt(0)];

  const existingIndex = glyphs.findIndex(g => g.name===selectedGlyph);
  const newGlyph = new opentype.Glyph({ name:selectedGlyph, unicodes:codes, advanceWidth:400, path:opentypePath });
  if(existingIndex>=0) glyphs[existingIndex]=newGlyph;
  else glyphs.push(newGlyph);

  localStorage.setItem('miniFontSavedPaths', JSON.stringify(savedPaths));
  alert(`Glyph "${selectedGlyph}" gespeichert!`);
  updatePreview();
};

// Alles löschen
document.getElementById('clear').onclick = () => { if(selectedGlyph) savedPaths[selectedGlyph]=[]; clearCanvas(); localStorage.setItem('miniFontSavedPaths', JSON.stringify(savedPaths)); };

// Undo/Redo
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// -----------------------------
// TTF Export
document.getElementById('download').onclick = () => {
  if(!glyphs.length){ alert('Keine Glyphen vorhanden!'); return; }
  const font = new opentype.Font({ familyName:'MyMiniFont', styleName:'Regular', unitsPerEm:400, ascender:350, descender:-50, glyphs:glyphs });
  const arrayBuffer = font.toArrayBuffer();
  const blob = new Blob([arrayBuffer], {type:'font/ttf'});
  const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download='MyMiniFont.ttf';
  document.body.appendChild(link); link.click(); document.body.removeChild(link);
};

// -----------------------------
// Live Preview
const previewInput=document.getElementById('previewText');
const previewDiv=document.getElementById('preview');
function updatePreview(){
  if(!glyphs.length) return;
  const tempFont = new opentype.Font({ familyName:'TempFont', styleName:'Regular', unitsPerEm:400, ascender:350, descender:-50, glyphs:glyphs });
  const fontUrl = tempFont.toDataURL();
  let style=document.getElementById('tempFontStyle');
  if(!style){ style=document.createElement('style'); style.id='tempFontStyle'; document.head.appendChild(style); }
  style.innerHTML = `@font-face { font-family:'TempFont'; src:url(${fontUrl}); }`;
  previewDiv.style.fontFamily='TempFont'; previewDiv.textContent=previewInput.value;
}
previewInput.addEventListener('input', updatePreview);

// -----------------------------
// Auto-Load aus LocalStorage
window.addEventListener('load', () => {
  const saved = localStorage.getItem('miniFontSavedPaths');
  if(saved){ try{ const obj=JSON.parse(saved); for(const key in obj){ savedPaths[key]=obj[key]; } } catch(e){ console.warn(e); } }
  updatePreview();
});
</script>
</body>
</html>
